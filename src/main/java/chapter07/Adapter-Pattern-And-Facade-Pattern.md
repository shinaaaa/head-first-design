# 어댑터 패턴

- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환
- 인터페이스가 호환되지 않아 같이 쓿 수 없었던 클래스를 사용할 수 있게 도와줌
- 기존 클래스를 사용하려고 하는데 인터페이스가 맞지 않으면 어댑터를 사용
- 인터페이스를 클라이언트에서 원하는 인터페이스로 바꾸는 역할을 함
- 구현할 때 타깃 인터페이스의 크기와 구조에 따라 코딩해야 할 분량이 결정됨
- 객체 어댑터 패턴과 클래스 어댑터 패턴이 있음
- 클래스 어댑터 패턴을 사용할 경우 다중 상속이 가능해야함
- 어댑터는 객체를 감싸서 인터페이스를 바꾸는 용도
- 데코레이터는 객체를 감싸서 새로운 행동을 추가하는 용도

# 퍼사드 패턴
- 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어 줌
- 고수준 인터페이스도 정의하므로 서브시스템을 더 편리하게 사용할 수 있음
- 큰 인터페이스와 여러 인터페이스를 단순하게 바꾸거나 통합해야하면 퍼스드를 사용
- 클라이언트를 복잡한 서브시스템과 분리하는 역할을 함
- 구현할 때 서브시스템으로 퍼사드를 만들고 진짜 작업은 서브클래스에 맡김
- 한 서브시스템에 퍼사드를 여러개 만들어도 됨
- 퍼사드는 일련의 객체를 감싸서 단순하게 만드는 용도로 쓰임

객체 지향 기초

- 추상화
- 캡슐화
- 다형성
- 상속

객체지향 원칙

- 바뀌는 부분을 캡슐화한다.
- 상속보다 구성을 활용한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야한다.
- 클래스는 확장에는 열려 있어야 하지만 변경에서는 닫혀 있어야한다.(OCP)
- 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
- 진짜 절친에게만 이야기해야 한다.
